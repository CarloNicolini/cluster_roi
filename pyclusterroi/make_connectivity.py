# make_connectivity.py
# Copyright (C) 2010 R. Cameron Craddock (cameron.craddock@gmail.com)
#
# This script is a part of the pyClusterROI python toolbox for the spatially
# constrained clustering of fMRI data. It constructs a spatially constrained
# connectivity matrix from a fMRI dataset, where then connectivity weight
# between two neighboring voxels is determined by the correlation between their
# BOLD time courses (tcorr), the correlation between functional connectivity
# maps generated by correlating the voxel time courses with every other voxel
# time course in the brain (scorr), or is 1 if the voxels are both in the brain
# and are neighbors.
#
# For more information refer to:
#
# Craddock, R. C.; James, G. A.; Holtzheimer, P. E.; Hu, X. P. & Mayberg, H. S.
# A whole brain fMRI atlas generated via spatially constrained spectral
# clustering Human Brain Mapping, 2012, 33, 1914-1928 doi: 10.1002/hbm.21333.
#
# ARTICLE{Craddock2012,
#   author = {Craddock, R C and James, G A and Holtzheimer, P E and Hu, X P and
#   Mayberg, H S},
#   title = {{A whole brain fMRI atlas generated via spatially constrained
#   spectral clustering}},
#   journal = {Human Brain Mapping},
#   year = {2012},
#   volume = {33},
#   pages = {1914--1928},
#   number = {8},
#   address = {Department of Neuroscience, Baylor College of Medicine, Houston,
#       TX, United States},
#   pmid = {21769991},
# }
#
# Documentation, updated source code and other information can be found at the
# NITRC web page: http://www.nitrc.org/projects/cluster_roi/ and on github at
# https://github.com/ccraddock/cluster_roi
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
####

# this scripts requires NumPy (numpy.scipy.org) to be installed in a directory
# that is accessible through PythonPath

import numpy as np
import warnings
import sklearn.preprocessing as skp
import itertools


def get_neighbors(ix, msz):

    """
    array to find the indices of the voxels in a 3D cube centered at ix

    :param ix: center of the cube, single number NOT a list
    :param msz: dimensions of the full space
    :return: list of 1d indices for the voxels of the cube
    """

    if np.ndim(ix) > 0:
        raise TabError("ix should be a single integer, not a list")

    # array to add to 3d coordinates of seed voxel to get the face, edge, and corner
    # touching neighbors
    neighbors = [np.array([[-1],
                           [1]]),
                 np.array([[-1, -1],
                           [0, -1],
                           [1, -1],
                           [-1, 0],
                           [1, 0],
                           [-1, 1],
                           [0, 1],
                           [1, 1]]),
                 np.array([[-1, -1, -1],
                           [0, -1, -1],
                           [1, -1, -1],
                           [-1, 0, -1],
                           [0, 0, -1],
                           [1, 0, -1],
                           [-1, 1, -1],
                           [0, 1, -1],
                           [1, 1, -1],
                           [-1, -1, 0],
                           [0, -1, 0],
                           [1, -1, 0],
                           [-1, 0, 0],
                           [1, 0, 0],
                           [-1, 1, 0],
                           [0, 1, 0],
                           [1, 1, 0],
                           [-1, -1, 1],
                           [0, -1, 1],
                           [1, -1, 1],
                           [-1, 0, 1],
                           [0, 0, 1],
                           [1, 0, 1],
                           [-1, 1, 1],
                           [0, 1, 1],
                           [1, 1, 1]])]

    if len(msz)-1 > 3 or len(msz) < 0:
        raise ValueError("Cannot calculate neighbors for %d dimensions", len(msz)-1)

    # get the neighbor indices, filtering out values that are outside of the image's
    # bounding box
    neighbor_indices = []
    for v in np.unravel_index(ix, msz) + neighbors[len(msz) - 1]:
        if (v >= 0).all() and (v < msz).all():
            neighbor_indices.append(v)

    # convert to 1D index and return
    return np.ravel_multi_index(tuple(np.transpose(neighbor_indices)), msz)


def ones_connectivity(im_array, mask_array, mask_3d_shape, mask_indices, thresh=0.5):
    """

    This function is a part of the ClusterROI python toolbox for the
    spatially constrained clustering of fMRI data. It constructs a spatially
    constrained connectivity matrix for a fMRI dataset. The weights w_ij of
    the connectivity matrix W are set to 1 if a voxel is within the 3D
    neighborhood (face, edge, and corner touching) of the center voxel.


    :param im_array: not used in this function, only included to conform with the prototype for connectivity functions
    :param mask_array: 2D matrix (voxels x 1) used to map 3D image coordinates to 2D im_array coordinates. Each value
         contains a zero if the voxel is outside the brain, or the index of the voxel in the im_array if the voxel is
         inside the brain.
    :param mask_3d_shape: the original shape of the mask image, used to calculate neighbors in 3D
    :param mask_indices: the mask indices for the voxels to be used as 'seeds' in the connectivity calculation
    :param thresh: Pearson correlation values above this threshold are included in the output
    :return: w, i, j where w is a list of weights (w_ij) and i and j are voxel coordinates
    """

    if isinstance(mask_indices, int):
        mask_indices = [mask_indices]

    w_values = []
    i_indices = []
    j_indices = []

    # loop over all of the voxels in the mask
    for mask_index in mask_indices:

        # look up the image index for the mask index
        image_index = mask_array[mask_index] - 1

        # get the neighbors and make sure that they are in the mask, could
        # do this as a list comprehension, but this way may make it more
        # readable?
        seed_neighbor_image_indices = []
        for neighbor_index in get_neighbors(mask_index, mask_3d_shape):
            if 0 <= neighbor_index <= np.prod(mask_array.shape) and mask_array[neighbor_index] > 0:
                seed_neighbor_image_indices.append(mask_array[neighbor_index] - 1)

        w_values += [float(1.0)] * len(seed_neighbor_image_indices)
        i_indices += [int(image_index)] * len(seed_neighbor_image_indices)
        j_indices += seed_neighbor_image_indices

    return w_values, i_indices, j_indices


def tcorr_connectivity(im_array, mask_array, mask_3d_shape, mask_indices, thresh=0.5):
    """

    This script is a part of the ClusterROI python toolbox for the spatially
    constrained clustering of fMRI data. It constructs a spatially constrained
    connectivity matrix from a fMRI dataset. The weights w_ij of the connectivity
    matrix W correspond to the _temporal_correlation_ between the time series
    from voxel i and voxel j. Connectivity is only calculated between a voxel and
    the 27 voxels in its 3D neighborhood (face and edge touching).

    :param im_array: 2d matrix (voxels x time) of voxel time series
    :param mask_array: 2D matrix (voxels x 1) used to map 3D image coordinates to 2D im_array coordinates. Each value
         contains a zero if the voxel is outside the brain, or the index of the voxel in the im_array if the voxel is
         inside the brain.
    :param mask_3d_shape: the original shape of the mask image, used to calculate neighbors in 3D
    :param mask_indices: the mask indices for the voxels to be used as 'seeds' in the connectivity calculation
    :param thresh: Pearson correlation values above this threshold are included in the output
    :return: w, i, j where w is a list of weights (w_ij) and i and j are voxel coordinates
    """

    if isinstance(mask_indices, int):
        mask_indices = [mask_indices]

    w_values = []
    i_indices = []
    j_indices = []

    for mask_index in mask_indices:

        # look up the image index for the mask index
        image_index = mask_array[mask_index] - 1

        # extract the seed_tc and make sure it has variance, otherwise
        # we are just wasting our time
        if image_index < im_array.shape[0]:
            seed_tc = im_array[image_index, :]
        else:
            raise ValueError("Index {0} is out of bounds {1} {2}".format(image_index, im_array.shape[0], im_array.shape[1]))

        if seed_tc.var() != 0:

            # get the neighbors and make sure that they are in the mask, could
            # do this as a list comprehension, but this way may make it more
            # readable?
            seed_neigh_img_ix = []
            for x in get_neighbors(mask_index, mask_3d_shape):
                if 0 <= x <= np.prod(mask_array.shape) and mask_array[x] > 0:
                    seed_neigh_img_ix.append(mask_array[x] - 1)

            # get the time courses for the neighbors
            neigh_tc = im_array[seed_neigh_img_ix, :]

            # calculate the correlation, and find the location of
            # values > thresh
            corr = (1.0 / im_array.shape[1]) * np.matmul(neigh_tc, seed_tc)

            if (corr > thresh).any():
                seed_neigh = np.array(seed_neigh_img_ix)
                corr_mask = corr > thresh
                seed_neigh = seed_neigh[corr_mask].tolist()
                corr = corr[corr_mask].tolist()

                w_values += corr
                i_indices += [int(image_index)] * len(seed_neigh)
                j_indices += seed_neigh

    return w_values, i_indices, j_indices


def scorr_connectivity(image_array, mask_array, mask_3d_shape, mask_indices, thresh=0.5):
    """
    This script is a part of the ClusterROI python toolbox for the spatially
    constrained clustering of fMRI data. It constructs a spatially constrained
    connectivity matrix from a fMRI data set. The weights w_ij of the connectivity
    matrix W correspond to the _spatial_correlation_ between functional connectivity
    maps generated from time series from voxel i and voxel j. Connectivity is
    only calculated between a voxel and the 27 voxels in its 3D neighborhood (face
    touching and edge touching).

    :param image_array: 2d matrix (voxels x time) of voxel time series
    :param mask_array: 2D matrix (voxels x 1) used to map 3D image coordinates to 2D im_array coordinates. Each value
         contains a zero if the voxel is outside the brain, or the index of the voxel in the im_array if the voxel is
         inside the brain.
    :param mask_3d_shape: the original shape of the mask image, used to calculate neighbors in 3D
    :param mask_indices: the mask indices for the voxels to be used as 'seeds' in the connectivity calculation
    :param thresh: Pearson correlation values above this threshold are included in the output
    :return: w, i, j where w is a list of weights (w_ij) and i and j are voxel coordinates
    """

    if isinstance(mask_indices, int):
        mask_indices = [mask_indices]

    w_values = []
    i_indices = []
    j_indices = []

    for mask_index in mask_indices:

        # look up the image index for the mask index
        image_index = mask_array[mask_index] - 1

        # extract the seed_tc and make sure it has variance, otherwise
        # we are just wasting our time
        if image_index < image_array.shape[0]:
            seed_time_course = image_array[image_index, :]
        else:
            raise ValueError(
                "Index {0} is out of bounds {1} {2}".format(image_index, image_array.shape[0], image_array.shape[1]))

        if seed_time_course.var(0) == 0:
            continue

        seed_ifc = (1.0/image_array.shape[1])*np.matmul(image_array, seed_time_course)

        if seed_ifc.var() == 0:
            continue

        seed_ifc = skp.scale(seed_ifc, axis=0, with_mean=True, with_std=True, copy=False)

        # get the neighbors and make sure that they are in the mask
        seed_neighbor_image_indices = []
        for index in get_neighbors(mask_index, mask_3d_shape):
            if 0 <= index <= np.prod(mask_array.shape) and mask_array[index] > 0:
                seed_neighbor_image_indices.append(mask_array[index] - 1)

        # reduce the neighbors to just those with variance
        neighbor_time_courses = image_array[seed_neighbor_image_indices, :]

        # filter neighbors and time series to remove those with no variance
        seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                       for index, value in enumerate(neighbor_time_courses.var(1))
                                       if value > 0]

        # reduce the neighbors to just those with variance
        neighbor_time_courses = image_array[seed_neighbor_image_indices, :]

        # calculate IFC for the neighbors
        neighbor_ifc = (1.0 / 150) * np.matmul(image_array, np.transpose(neighbor_time_courses))

        # jump to the next seed if none of the resulting maps have variance
        if (neighbor_ifc.var(0) == 0).all():
            continue

        # now filter out the neighbors whose iFC maps have no variance
        # filter neighbors and time series to remove those with no variance
        seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                       for index, value in enumerate(neighbor_ifc.var(0))
                                       if value > 0]

        neighbor_ifc = neighbor_ifc[:, neighbor_ifc.var(0) > 0]

        # standardize the ifc maps in preparation for the correlation
        neighbor_ifc = skp.scale(neighbor_ifc, axis=0, with_mean=True, with_std=True, copy=False)

        # calculate the correlation, and find the location of values > thresh
        corr = (1.0/image_array.shape[0])*(np.matmul(seed_ifc, neighbor_ifc))

        # now find the neighbors with a correlation above threshold, and
        # the corresponding weight
        if (corr > thresh).any():
            seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                           for index, value in enumerate(corr)
                                           if value > thresh]

            corr = [value for index, value in enumerate(corr) if value > thresh]

            w_values += corr
            i_indices += [int(image_index)] * len(seed_neighbor_image_indices)
            j_indices += seed_neighbor_image_indices

    return w_values, i_indices, j_indices


def make_local_connectivity_clusters(im_array):
    """

    make_local_connectivity_ones( mask_array )

    This function is a part of the ClusterROI python toolbox for the
    spatially constrained clustering of fMRI data. It constructs a spatially
    constrained connectivity matrix for a fMRI dataset. The weights w_ij of
    the connectivity matrix W are set to 1 if a voxel is contained in the
    same ROI (determined by a unique integer identifier) as the seed vx.

    Args:
        :param im_array: (numpy array) containing cluster assignment data

    Returns:
        w, i, j : w is a list of connection weights, i is a list of connection left coordinates,
             j is  a list of connection right coordinates

    :rtype: tuple
    """

    warnings.filterwarnings("ignore", category=UserWarning)

    i_indices = []
    j_indices = []

    for cluster_val in np.unique(im_array):
        cluster_ixs = [i for i, v in enumerate(im_array) if v == cluster_val]
        i_indices += [i for (i, j) in itertools.product(cluster_ixs, repeat=2) if i != j]
        j_indices += [j for (i, j) in itertools.product(cluster_ixs, repeat=2) if i != j]

    w_values = [1.0] * len(i_indices)

    return w_values, i_indices, j_indices


def make_local_connectivity(method, image_array, mask_array, thresh=0.5, num_threads=1):

    """
    This script is a part of the ClusterROI python toolbox for the spatially
    constrained clustering of fMRI data. It is a wrapper that calculates a spatially constrained connectivity
    matrix from a fMRI dataset using multiple threads. Connectivity is only calculated between a voxel and
    the 27 voxels in its 3D neighborhood (face and edge touching). Does not calculate 'cluster' connectivity.

    :param method: string indicating how connectivity should be calculated
              should be one of 'tcorr', 'scorr', or 'ones', which are defined as:

              ones: construct a binary adjacency matrix from a mask file where two voxels are considered connected if
                 they are touching neighbors (face and edge)
              tcorr: construct a binary adjacency matrix from 4D fMRI data, where two voxels are considered connected
                 if they are touching neighbors (face and edge) and the pearson's correlation between their time series
                 are greater than thresh
              scorr: construct a binary adjacency matrix from 4D fMRI data, where two voxels are considered connected
                 if they are touching neighbors (face and edge) and the pearson's correlation between their whole brain
                 functional connectivity maps (calculated from the temporal correlation between a voxel's time series
                 and the time series of every voxel in the brain) are greater than thresh
    :param image_array: 2D (vx by tc) array containing fMRI data, if using 'ones' method image_array is ignored
    :param mask_array: 3D mask to use for restricting the calculations
    :param thresh: Threshold value, correlation coefficients lower than this value
               will be removed from the matrix (set to zero).
    :param num_threads: number of threads used to calculate connectivity in parallel
    :return: w, i, j : w is a list of connection weights, i is a list of connection left coordinates,
             j is  a list of connection right coordinates
    """

    connectivity_method_dict = {
        'ones': ones_connectivity,
        'scorr': scorr_connectivity,
        'tcorr': tcorr_connectivity
    }

    method = method.lower()

    if method and method in connectivity_method_dict:
        connectivity_function = connectivity_method_dict[method]
    else:
        raise ValueError(
            "Don't understand method {0}, should be one of {1}".format(method, connectivity_method_dict.keys()))

    warnings.filterwarnings("ignore", category=UserWarning)

    mask_3d_shape = mask_array.shape
    mask_array = mask_array.flatten()

    if method in ['scorr', 'tcorr']:
        if isinstance(image_array, type(None)):
            raise ValueError("Calculating connectivity using {0} requires imaging data, None received.".format(method))

        # standardize everything at once to make correlation calculation easier
        image_array = skp.scale(image_array, axis=1, with_mean=True, with_std=True, copy=False)

    # create blocks of voxel indices that will be assigned to the thread pool for connectivity calculation
    mask_indices = [i for i, x in enumerate(mask_array) if x > 0]

    w_values = []
    i_indices = []
    j_indices = []

    if num_threads == 1:

        (w_values, i_indices, j_indices) = connectivity_function(image_array, mask_array, mask_3d_shape, mask_indices, thresh)

    elif num_threads > 1:

        import multiprocessing as mp

        mask_index_blocks = []
        ids_per_block = int(np.ceil(len(mask_indices)/num_threads))

        for thread_id in range(0, num_threads):
            start_index = thread_id * ids_per_block
            end_index = min(start_index + ids_per_block, len(mask_indices))
            mask_index_blocks.append(mask_indices[start_index:end_index])

        # calculate each desired clustering result
        with mp.Pool(processes=num_threads) as pool:

            apply_results = []
            for mask_index_block in mask_index_blocks:
                apply_results.append(
                    pool.apply_async(connectivity_function,
                                     (image_array, mask_array, mask_3d_shape, mask_index_block, thresh)))

            for result in apply_results:
                (w, i, j) = result.get()

                w_values += w
                i_indices += i
                j_indices += j

    return w_values, i_indices, j_indices