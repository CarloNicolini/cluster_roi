#### make_connectivity.py
# Copyright (C) 2010 R. Cameron Craddock (cameron.craddock@gmail.com)
#
# This script is a part of the pyClusterROI python toolbox for the spatially
# constrained clustering of fMRI data. It constructs a spatially constrained
# connectivity matrix from a fMRI dataset, where then connectivity weight
# between two neighboring voxels is determined by the correlation between their
# BOLD time courses (tcorr), the correlation between functional connectivity
# maps generated by correlating the voxel time courses with every other voxel
# time course in the brain (scorr), or is 1 if the voxels are both in the brain
# and are neighbors.
#
# For more information refer to:
#
# Craddock, R. C.; James, G. A.; Holtzheimer, P. E.; Hu, X. P. & Mayberg, H. S.
# A whole brain fMRI atlas generated via spatially constrained spectral
# clustering Human Brain Mapping, 2012, 33, 1914-1928 doi: 10.1002/hbm.21333.
#
# ARTICLE{Craddock2012,
#   author = {Craddock, R C and James, G A and Holtzheimer, P E and Hu, X P and
#   Mayberg, H S},
#   title = {{A whole brain fMRI atlas generated via spatially constrained
#   spectral clustering}},
#   journal = {Human Brain Mapping},
#   year = {2012},
#   volume = {33},
#   pages = {1914--1928},
#   number = {8},
#   address = {Department of Neuroscience, Baylor College of Medicine, Houston,
#       TX, United States},
#   pmid = {21769991},
# }
#
# Documentation, updated source code and other information can be found at the
# NITRC web page: http://www.nitrc.org/projects/cluster_roi/ and on github at
# https://github.com/ccraddock/cluster_roi
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
####

# this scripts requires NumPy (numpy.scipy.org) to be installed in a directory
# that is accessible through PythonPath

import time
import nibabel as nb
import numpy as np
import warnings
import sklearn.preprocessing as skp
import itertools
import scipy.sparse as sp


def get_neighbors(ix, msz):

    """
    array to find the indices of the voxels in a 3D cube centered at ix

    :param ix: center of the cube, single number NOT a list
    :param msz: dimensions of the full space
    :return: list of 1d indices for the voxels of the cube
    """

    if np.ndim(ix) > 0:
        raise TabError("ix should be a single integer, not a list")

    # array to add to 3d coordinates of seed voxel to get the face, edge, and corner
    # touching neighbors
    neighbors = [np.array([[-1],
                           [1]]),
                 np.array([[-1, -1],
                           [0, -1],
                           [1, -1],
                           [-1, 0],
                           [1, 0],
                           [-1, 1],
                           [0, 1],
                           [1, 1]]),
                 np.array([[-1, -1, -1],
                           [0, -1, -1],
                           [1, -1, -1],
                           [-1, 0, -1],
                           [0, 0, -1],
                           [1, 0, -1],
                           [-1, 1, -1],
                           [0, 1, -1],
                           [1, 1, -1],
                           [-1, -1, 0],
                           [0, -1, 0],
                           [1, -1, 0],
                           [-1, 0, 0],
                           [1, 0, 0],
                           [-1, 1, 0],
                           [0, 1, 0],
                           [1, 1, 0],
                           [-1, -1, 1],
                           [0, -1, 1],
                           [1, -1, 1],
                           [-1, 0, 1],
                           [0, 0, 1],
                           [1, 0, 1],
                           [-1, 1, 1],
                           [0, 1, 1],
                           [1, 1, 1]])]

    if len(msz)-1 > 3 or len(msz) < 0:
        raise ValueError("Cannot calculate neighbors for %d dimensions", len(msz)-1)

    # get the neighbor indices, filtering out values that are outside of the image's
    # bounding box
    neighbor_indices = []
    for v in np.unravel_index(ix, msz) + neighbors[len(msz) - 1]:
        if (v >= 0).all() and (v < msz).all():
            neighbor_indices.append(v)

    # convert to 1D indx and return
    return np.ravel_multi_index(tuple(np.transpose(neighbor_indices)), msz)


def make_local_connectivity_ones(mask_array):
    """

    make_local_connectivity_ones( mask_array )

    This function is a part of the ClusterROI python toolbox for the
    spatially constrained clustering of fMRI data. It constructs a spatially
    constrained connectivity matrix for a fMRI dataset. The weights w_ij of
    the connectivity matrix W are set to 1 if a voxel is within the 3D
    neighborhood (face, edge, and corner touching) of the center voxel.

    Args:
        mask_array (numpy array): 1, 2, or 3 -dimensional array with ones at
          locations that are considered "in-brain" voxels, and zero everywhere
          else

    Returns:
        edge_ndx (list of tuples): each tuple corresponds to a edge with
           (start node ndx, end node ndx, edge weight)

    :rtype: list
    """

    warnings.filterwarnings("ignore", category=UserWarning)

    msz = mask_array.shape
    mask_num_vx = np.prod(msz)

    mask_array = mask_array.flatten()

    mask_ixs = [i for i, x in enumerate(mask_array) if x > 0]

    w_vals = []
    i_ndx = []
    j_ndx = []

    # loop over all of the voxels in the mask
    for ix in mask_ixs:

        # look up the image index for the mask index
        im_indx = mask_array[ix] - 1

        # get the neighbors and make sure that they are in the mask, could
        # do this as a list comprehension, but this way may make it more
        # readable?
        seed_neigh_image_ix = []
        for x in get_neighbors(ix, msz):
            if 0 <= x <= mask_num_vx and mask_array[x] > 0:
                seed_neigh_image_ix.append(mask_array[x] - 1)

        w_vals += [float(1.0)] * len(seed_neigh_image_ix)
        i_ndx += [int(im_indx)] * len(seed_neigh_image_ix)
        j_ndx += seed_neigh_image_ix

    return w_vals, i_ndx, j_ndx


def make_local_connectivity_tcorr(im_array, mask_array, thresh):

    """
    This script is a part of the ClusterROI python toolbox for the spatially
    constrained clustering of fMRI data. It constructs a spatially constrained
    connectivity matrix from a fMRI dataset. The weights w_ij of the connectivity
    matrix W correspond to the _temporal_correlation_ between the time series
    from voxel i and voxel j. Connectivity is only calculated between a voxel and
    the 27 voxels in its 3D neighborhood (face and edge touching). The resulting
    datafiles are suitable as inputs to the function
    binfile_parcellate.

    :param im_array: 2D (vx by tc) array containing fMRI data
    :param mask_array: mask to use for restricting the calculations
    :param thresh: Threshold value, correlation coefficients lower than this value
               will be removed from the matrix (set to zero).
    :return: w, i, j : w is a list of connection weights, i is a list of connection left coordinates,
             j is  a list of connection right coordinates
    """

    warnings.filterwarnings("ignore", category=UserWarning)

    msz = mask_array.shape
    mask_num_vx = np.prod(msz)

    mask_array = mask_array.flatten()

    mask_ixs = [i for i, x in enumerate(mask_array) if x > 0]

    (num_vx, num_tc) = im_array.shape

    # standardize everything at once to make correlation calculation easier
    im_array = skp.scale(im_array, axis=1, with_mean=True, with_std=True, copy=False)

    w_vals = []
    i_ndx = []
    j_ndx = []

    # loop over all of the voxels in the mask
    for ix in mask_ixs:

        # look up the image index for the mask index
        im_indx = mask_array[ix] - 1

        # extract the seed_tc and make sure it has variance, otherwise
        # we are just wasting our time
        if im_indx < num_vx:
            seed_tc = im_array[im_indx, :]
        else:
            print("how is {0} out of bounds? {1} {2}".format(im_indx, num_vx, num_tc))

        if seed_tc.var() == 0:
            continue

        # get the neighbors and make sure that they are in the mask, could
        # do this as a list comprehnsion, but this way may make it more
        # readable?
        seed_neigh_img_ix = []
        for x in get_neighbors(ix, msz):
            if 0 <= x <= mask_num_vx and mask_array[x] > 0:
                seed_neigh_img_ix.append(mask_array[x] - 1)

        # get the time courses for the neighbors
        neigh_tc = im_array[seed_neigh_img_ix, :]

        # calculate the correlation, and find the location of
        # values > thresh
        corr = (1.0/num_tc)*np.matmul(neigh_tc, seed_tc)

        if (corr > thresh).any():
            seed_neigh = np.array(seed_neigh_img_ix)
            corr_mask = corr > thresh
            seed_neigh = seed_neigh[corr_mask].tolist()
            corr = corr[corr_mask].tolist()

            w_vals += corr
            i_ndx += [int(im_indx)] * len(seed_neigh)
            j_ndx += seed_neigh

    return w_vals, i_ndx, j_ndx


def make_local_connectivity_scorr(image_array, mask_array, thresh):

    """
    This script is a part of the ClusterROI python toolbox for the spatially
    constrained clustering of fMRI data. It constructs a spatially constrained
    connectivity matrix from a fMRI data set. The weights w_ij of the connectivity
    matrix W correspond to the _spatial_correlation_ between functional connectivity
    maps generated from time series from voxel i and voxel j. Connectivity is
    only calculated between a voxel and the 27 voxels in its 3D neighborhood (face
    touching and edge touching).

    :param image_array: 2D (vx by tc) array containing fMRI data
    :param mask_array: 1, 2, or 3 -dimensional array with ones at
          locations that are considered "in-brain" voxels, and zero everywhere
          else
    :param thresh: Threshold value, correlation coefficients lower than this value
               will be removed from the matrix (set to zero).
    :return:  w, i, j : w is a list of connection weights, i is a list of connection left coordinates,
             j is  a list of connection right coordinates

    :rtype: tuple
    """

    warnings.filterwarnings("ignore", category=UserWarning)

    mask_shape = mask_array.shape
    mask_num_voxels = np.prod(mask_shape)

    mask_array = mask_array.flatten()

    mask_indices = [index for index, value in enumerate(mask_array) if value > 0]

    (image_num_voxels, image_num_time_points) = image_array.shape

    # standardize everything at once to make correlation calculation easier
    im_array = skp.scale(image_array, axis=1, with_mean=True, with_std=True, copy=False)

    w_values = []
    i_indices = []
    j_indices = []

    # loop over all of the voxels in the mask
    for mask_index in mask_indices:

        # look up the image index for the mask index
        image_index = mask_array[mask_index] - 1

        # extract the seed_tc and make sure it has variance, otherwise
        # we are just wasting our time
        if image_index < image_num_voxels:
            seed_time_course = image_array[image_index, :]
        else:
            print("how is {0} out of bounds? {1} {2}".format(image_index,
                                                             image_num_voxels,
                                                             image_num_time_points))

        if seed_time_course.var(0) == 0:
            continue

        seed_ifc = (1.0/image_num_time_points)*np.matmul(image_array, seed_time_course)

        if seed_ifc.var() == 0:
            continue

        seed_ifc = skp.scale(seed_ifc, axis=0, with_mean=True, with_std=True, copy=False)

        # get the neighbors and make sure that they are in the mask
        seed_neighbor_image_indices = []
        for index in get_neighbors(mask_index, mask_shape):
            if 0 <= index <= mask_num_voxels and mask_array[index] > 0:
                seed_neighbor_image_indices.append(mask_array[index] - 1)

        # reduce the neighbors to just those with variance
        neighbor_time_courses = im_array[seed_neighbor_image_indices, :]

        # filter neighbors and time series to remove those with no variance
        seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                       for index, value in enumerate(neighbor_time_courses.var(1))
                                       if value > 0]

        # reduce the neighbors to just those with variance
        neighbor_time_courses = im_array[seed_neighbor_image_indices, :]

        # calculate IFC for the neighbors
        neighbor_ifc = (1.0 / 150) * np.matmul(im_array, np.transpose(neighbor_time_courses))

        # jump to the next seed if none of the resulting maps have variance
        if (neighbor_ifc.var(0) == 0).all():
            continue

        # now filter out the neighbors whose iFC maps have no variance
        # filter neighbors and time series to remove those with no variance
        seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                       for index, value in enumerate(neighbor_ifc.var(0))
                                       if value > 0]

        neighbor_ifc = neighbor_ifc[:, neighbor_ifc.var(0) > 0]

        # standardize the ifc maps in preparation for the correlation
        neighbor_ifc = skp.scale(neighbor_ifc, axis=0, with_mean=True, with_std=True, copy=False)

        # calculate the correlation, and find the location of values > thresh
        corr = (1.0/image_num_voxels)*(np.matmul(seed_ifc, neighbor_ifc))

        # now find the neighbors with a correlation above threshold, and
        # the corresponding weight
        if (corr > thresh).any():
            seed_neighbor_image_indices = [seed_neighbor_image_indices[index]
                                           for index, value in enumerate(corr)
                                           if value > thresh]

            corr = [value for index, value in enumerate(corr) if value > thresh]

            w_values += corr
            i_indices += [int(image_index)] * len(seed_neighbor_image_indices)
            j_indices += seed_neighbor_image_indices

    return w_values, i_indices, j_indices


def make_local_connectivity_clusters(im_array):
    """

    make_local_connectivity_ones( mask_array )

    This function is a part of the ClusterROI python toolbox for the
    spatially constrained clustering of fMRI data. It constructs a spatially
    constrained connectivity matrix for a fMRI dataset. The weights w_ij of
    the connectivity matrix W are set to 1 if a voxel is contained in the
    same ROI (determined by a unique integer identifier) as the seed vx.

    Args:
        :param im_array: (numpy array) containing cluster assignment data

    Returns:
        w, i, j : w is a list of connection weights, i is a list of connection left coordinates,
             j is  a list of connection right coordinates

    :rtype: tuple
    """

    warnings.filterwarnings("ignore", category=UserWarning)

    i_indices = []
    j_indices = []

    for cluster_val in np.unique(im_array):
        cluster_ixs = [i for i, v in enumerate(im_array) if v == cluster_val]
        i_indices += [i for (i, j) in itertools.product(cluster_ixs, repeat=2) if i != j]
        j_indices += [j for (i, j) in itertools.product(cluster_ixs, repeat=2) if i != j]

    w_values = [1.0] * len(i_indices)

    return w_values, i_indices, j_indices